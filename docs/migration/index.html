<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Baseline for Obsidian</title>
    <link rel="icon" href="../favicon.svg" type="image/svg+xml" />

    <link rel="stylesheet" href="../main.css" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-38V3HD97K9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-38V3HD97K9");
    </script>
  </head>
  <body>
    <div class="header">
      <div class="header-title">
        <h1>
          <a href=".."><i data-lucide="chevron-left"></i>Baseline for Obsidian</a><span>/</span>
        </h1>
        <h1>Style Settings Migration Tool</h1>
      </div>
      <div class="header-actions">
        <a href="https://github.com/aaaaalexis/obsidian-baseline" class="header-link">View Baseline on GitHub</a>
      </div>
    </div>
    <div class="content">
      <div class="setting-container" title='Click the "Export" on top or the cloud icon for selected theme to export your settings.'>
        <div class="setting">
          <div class="setting-sidebar">
            <div class="sidebar-section">
              <div class="sidebar-title">Community plugins</div>
              <div class="sidebar-link is-active">Style Settings</div>
            </div>
          </div>
          <div class="setting-content">
            <div class="setting-header">
              <div class="setting-search">
                <i data-lucide="search"></i>
                Search Style Settings...
              </div>
              <div class="setting-actions">
                <button>Import</button>
                <button>Export</button>
              </div>
            </div>
            <div class="setting-list">
              <div class="setting-item">
                <i data-lucide="chevron-right"></i>
                <div class="setting-item-name">Theme</div>
                <div class="setting-item-actions"><i data-lucide="rotate-ccw"></i><i data-lucide="cloud-download"></i></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <p>Export your existing Style Settings, then paste here to migrate to Baseline-compatible settings.</p>
      <div class="panel-container">
        <div class="input-panel">
          <textarea
            class="prefs-input"
            placeholder='{
  "minimal-style@@bg1@@light": "#FFFFFF",
  "minimal-style@@tabs-style": "tabs-modern"
}


Supported themes:
- Minimal
- AnuPpuccin
- Border
- Sanctum
- Things 2'
          ></textarea>
          <div class="panel-actions">
            <button class="clear-btn">Clear</button>
          </div>
          <div class="warning-container"></div>
        </div>
        <div class="output-panel">
          <textarea class="prefs-output" disabled readonly></textarea>
          <div class="panel-actions">
            <button class="copy-btn">
              <span><i data-lucide="copy"></i>Copy</span>
            </button>
            <a class="download-btn" href="#" download="baseline-style-settings.json"><button>Download</button></a>
          </div>
          <div class="conflict-container"></div>
          <div class="unsupported-container"></div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const $ = (s, r = document) => r.querySelector(s);
        const prefsInput = $(".prefs-input");
        const prefsOutput = $(".prefs-output");
        const copyBtn = $(".copy-btn");
        const downloadBtn = $(".download-btn");
        const warningDiv = $(".warning-container");
        const conflictDiv = $(".conflict-container");
        const unsupportedDiv = $(".unsupported-container");
        const clearBtn = $(".clear-btn");

        const jsonCache = new Map();
        const fetchJSONOnce = async (url) => {
          if (jsonCache.has(url)) return jsonCache.get(url);
          const res = await fetch(url);
          if (!res.ok) throw new Error(`Status: ${res.status}`);
          const data = await res.json();
          jsonCache.set(url, data);
          return data;
        };
        const getMapping = () => fetchJSONOnce("mapping.json");
        const getBaselineLabels = () => fetchJSONOnce("mapping-baseline.json");
        const stripThemeSuffix = (s) => s.replace(/@@(light|dark)$/i, "");
        const isHex6 = (v) => typeof v === "string" && /^#[0-9A-Fa-f]{6}$/.test(v);
        const isColorCode = (v) => typeof v === "string" && (/^#[0-9A-Fa-f]{3,8}$/.test(v) || /^rgb\s*\(.*\)$/.test(v) || /^rgba\s*\(.*\)$/.test(v) || /^hsl\s*\(.*\)$/.test(v) || /^hsla\s*\(.*\)$/.test(v));
        const groupBy = (arr, fn) => arr.reduce((m, x) => ((m[fn(x)] ??= []).push(x), m), {});
        const setHTML = (n, h = "") => (n.innerHTML = h);

        const migratePrefs = (mapping, oldPrefs) => {
          const newPrefs = {},
            unsupported = [],
            conflicts = {},
            themeBases = {};
          for (const t in mapping) if (mapping[t]?.__name) themeBases[t] = mapping[t].__name;
          for (const k in oldPrefs) {
            if (!Object.hasOwnProperty.call(oldPrefs, k)) continue;
            const seg = k.split("@@");
            if (seg.length < 2) continue;
            const base = seg[0];
            const themeKey = Object.keys(themeBases).find((t) => base.startsWith(t));
            if (!themeKey) continue;
            const [, oldId, ...extra] = seg;
            const rules = Array.isArray(mapping[themeKey][oldId]) ? mapping[themeKey][oldId] : [mapping[themeKey][oldId]];
            const val = oldPrefs[k];
            if (!rules[0]) {
              const nk = ["baseline-style", oldId, ...extra].join("@@");
              newPrefs[nk] !== undefined ? (conflicts[nk] ??= [newPrefs[nk]]).push(val) : (newPrefs[nk] = val);
              continue;
            }
            for (const rule of rules) {
              if (!rule) continue;
              if (rule.unsupported) {
                unsupported.push({ name: rule.name || `Key '${oldId}'`, category: rule.category || "General", oldValue: val, theme: themeKey });
                continue;
              }
              let newVal = val;
              let newKey = rule.newId || oldId;
              if (rule.valueMapping) {
                const vr = rule.valueMapping[val];
                if (vr === undefined) {
                  if (rule.valueMapping.__fallback !== undefined) newVal = rule.valueMapping.__fallback;
                  else {
                    unsupported.push({ name: `Value '${val}' for setting '${oldId}'`, category: rule.category || "Unsupported Options", theme: themeKey });
                    continue;
                  }
                } else if (vr?.unsupported) {
                  unsupported.push({ name: vr.name || `Option '${val}'`, category: vr.category || "General", theme: themeKey });
                  continue;
                } else newVal = vr;
              }
              const assign = (nk) => {
                const final = ["baseline-style", nk, ...extra].join("@@");
                if (newPrefs[final] !== undefined) (conflicts[final] ??= [newPrefs[final]]).push(newVal);
                else newPrefs[final] = newVal;
              };
              Array.isArray(newKey) ? newKey.forEach(assign) : assign(newKey);
            }
          }
          for (const k in conflicts) {
            const vals = conflicts[k];
            if (vals.every((v) => v === vals[0])) {
              newPrefs[k] = vals[0];
              delete conflicts[k];
            } else conflicts[k] = Array.from(new Set(vals));
          }
          return { newPrefs, unsupported, themeBases, conflicts };
        };

        const renderWarnings = async (prefs) => {
          const labels = (await getBaselineLabels().catch(() => ({}))) || {};
          const keys = Object.keys(prefs).filter((k) => typeof prefs[k] === "string" && /\d/.test(prefs[k]) && !isColorCode(prefs[k]));
          if (!keys.length) return setHTML(warningDiv);
          let html = `<h2 class="warning-title">Note</h2><div class="warning-content"><div class="warning-description">Following settings might not work correctly, please double check after importing.</div><ul class="warning-list">`;
          keys.forEach((k) => {
            const lab = labels[stripThemeSuffix(k.replace(/^baseline-style@@/, ""))] || stripThemeSuffix(k);
            html += `<li class="warning-item">${lab}</li>`;
          });
          html += `</ul></div>`;
          setHTML(warningDiv, html);
        };

        let conflictListenerSetup = false;
        const renderConflicts = async (conflicts, prefs) => {
          const labels = (await getBaselineLabels().catch(() => ({}))) || {};
          if (!Object.keys(conflicts).length) return setHTML(conflictDiv);
          let html = `<h2>Conflicts</h2>`;
          for (const key in conflicts) {
            const stripped = key.replace(/^baseline-style@@/, "");
            const labelKey = stripThemeSuffix(stripped);
            const themeType = stripped.includes("@@light") ? "Light Theme" : stripped.includes("@@dark") ? "Dark Theme" : "";
            const display = labels[labelKey] || labelKey;
            html += `<div class="conflict-item"><div class="conflict-key">${display}</div>`;
            if (themeType) html += `<div class="conflict-theme">${themeType}</div>`;
            html += `<div class="conflict-actions">`;
            conflicts[key].forEach((val, idx) => {
              const valueLabel = labels[val] || val;
              html += `<label data-conflict-key="${key}" data-conflict-value="${val}" class="conflict-label${idx === 0 ? " selected" : ""}">` + valueLabel + (isHex6(val) ? `<span class="color-preview" style="background-color: ${val};"></span>` : "") + `</label>`;
            });
            html += `</div></div>`;
          }
          setHTML(conflictDiv, html);
          if (!conflictListenerSetup) {
            conflictDiv.addEventListener("click", (e) => {
              const label = e.target.closest?.(".conflict-label");
              if (!label || !conflictDiv.contains(label)) return;
              const key = label.dataset.conflictKey;
              conflictDiv.querySelectorAll(`[data-conflict-key='${key}']`).forEach((l) => l.classList.remove("selected"));
              label.classList.add("selected");
              const selected = { ...prefs };
              conflictDiv.querySelectorAll(".conflict-label.selected").forEach((sel) => {
                let v = sel.dataset.conflictValue;
                if (v === "true") v = true;
                else if (v === "false") v = false;
                selected[sel.dataset.conflictKey] = v;
              });
              updateOutput(selected);
            });
            conflictListenerSetup = true;
          }
        };

        const renderUnsupported = (unsupported, themeBases) => {
          if (!unsupported.length) return setHTML(unsupportedDiv);
          let html = `<h2>Unsupported style settings</h2>`;
          const byTheme = groupBy(unsupported, (i) => i.theme || "unknown");
          for (const theme in byTheme) {
            const readable = themeBases?.[theme] || theme;
            html += `<div class="unsupported-theme"><div class="unsupported-theme-name">${readable}</div>`;
            const byCat = groupBy(byTheme[theme], (i) => i.category || "General");
            for (const cat in byCat) {
              const seen = new Set();
              html += `<div class="unsupported-category"><div class="unsupported-category-name">${cat}</div><ul class="unsupported-list">`;
              byCat[cat].forEach((item) => {
                const stripped = item.name.replace(/@@(light|dark)$/i, "");
                if (seen.has(stripped)) return;
                seen.add(stripped);
                html += `<li class="unsupported-item">${item.name}</li>`;
              });
              html += `</ul></div>`;
            }
            html += `</div>`;
          }
          setHTML(unsupportedDiv, html);
        };

        const updateOutput = (prefs) => {
          const str = Object.keys(prefs).length ? JSON.stringify(prefs, null, 2) : "";
          prefsOutput.value = str;
          downloadBtn.href = "data:text/json;charset=utf-8," + encodeURIComponent(str);
        };

        const showResults = async (prefs, unsupported, themeBases, conflicts) => {
          updateOutput(prefs);
          renderUnsupported(unsupported, themeBases);
          await renderWarnings(prefs);
          await renderConflicts(conflicts, prefs);
        };

        copyBtn.onclick = () =>
          navigator.clipboard.writeText(prefsOutput.value).then(() => {
            copyBtn.innerHTML = "<span>Copied!</span>";
            setTimeout(() => (copyBtn.innerHTML = "<span>Copy</span>"), 1000);
            if (typeof gtag === "function") gtag("event", "migration_copy");
          });
        downloadBtn.onclick = () => {
          if (typeof gtag === "function") gtag("event", "migration_download");
        };
        clearBtn.onclick = () => {
          prefsInput.value = "";
          showResults({}, [], {}, {});
        };

        let last = "";
        prefsInput.addEventListener("input", () => {
          const val = prefsInput.value;
          if (val === last) return;
          last = val;
          if (!val.trim()) return showResults({}, [], {}, {});
          getMapping()
            .then((mapping) => {
              let oldPrefs;
              try {
                oldPrefs = JSON.parse(val);
              } catch (e) {
                showResults({}, [], {}, {});
                prefsOutput.value = `Error parsing preferences: ${e.message}`;
                return;
              }
              showResults(...Object.values(migratePrefs(mapping, oldPrefs)));
            })
            .catch((e) => {
              showResults({}, [], {}, {});
              prefsOutput.value = `Error loading mapping file: ${e.message || e}`;
            });
        });

        showResults({}, [], {}, {});
      })();
    </script>
    <script src="https://unpkg.com/lucide@latest" onload="lucide.createIcons()"></script>
  </body>
</html>
